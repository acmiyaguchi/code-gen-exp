# 3D Mountain Visualization Design Document

## Overview
This program generates and renders a 3D mountain terrain using Love2D, implementing basic 3D projection techniques without using OpenGL directly. The visualization features one dominant mountain peak surrounded by smaller mountains on a green landscape. The user can orbit around the scene and zoom in/out to view the mountain from any angle and distance.

## Technical Architecture

### Core Components
1. **Terrain Generation** - Creates a heightmap using Perlin noise with one dominant peak and multiple smaller peaks
2. **3D Projection System** - Projects 3D coordinates onto a 2D screen using world rotation and fixed camera
3. **Rendering Engine** - Draws the terrain as triangles with height-based coloring (green ground, brown mountains, snow-capped peaks)
4. **User Input Handling** - Processes keyboard, mouse, and scroll wheel input for rotation and zooming

### Technologies Used
- **Love2D** - 2D game framework (used here for 3D visualization)
- **Lua** - Programming language

## Implementation Details

### Terrain Generation
The terrain consists of:
- One large central mountain peak
- Several smaller randomly placed mountains
- A flat green ground around the mountains

The heightmap is generated by combining:
1. A central peak with steep falloff from center
2. Multiple smaller peaks with random placement
3. Perlin noise for natural variations in terrain

```lua
-- Main mountain generation logic
local mainMountainFactor = math.max(0, 1 - (distanceFromCenter / (maxDistance * 0.6)))
mainMountainFactor = mainMountainFactor * mainMountainFactor  -- Exponential falloff

-- Additional small mountains
for i = 1, 5 do  -- 5 smaller mountains
    local mx = love.math.random(1, numPointsX)
    local mz = love.math.random(1, numPointsZ)
    local mdist = math.sqrt((x - mx)^2 + (z - mz)^2)
    smallMountains = smallMountains + math.max(0, 1 - (mdist / (maxDistance * 0.15))) * mheight * terrainHeight
end
```

### 3D Projection and World Rotation
The program implements a fixed camera with rotating world system:
1. The camera remains in a fixed position
2. The world (terrain) rotates around the Y-axis
3. This creates an orbiting effect without moving the camera

```lua
-- World rotation approach instead of camera rotation
local worldX = point.x * math.cos(worldRotationY) - point.z * math.sin(worldRotationY)
local worldZ = point.x * math.sin(worldRotationY) + point.z * math.cos(worldRotationY)
local worldY = point.y
```

### Camera Zooming System
The program allows zooming by changing the camera's Z position:
1. Up arrow key or mouse wheel up: Zoom in (move camera closer)
2. Down arrow key or mouse wheel down: Zoom out (move camera farther)
3. Minimum and maximum zoom distances are enforced to prevent extreme views

```lua
-- Zooming controls
local zoomSpeed = 50
local minZoomDistance = 600
local maxZoomDistance = 1800
```

### Terrain Coloring
The terrain color is height-based:
- **Green** (0-5% height): Ground/grass
- **Green to Brown gradient** (5-40% height): Lower mountain slopes
- **Brown** (40-75% height): Mountain sides
- **Brown to White gradient** (75-100% height): Snow-capped peaks

### Rendering System
The terrain is rendered using the painter's algorithm for handling depth:
1. All triangles are collected with their average depth from the camera
2. Triangles are sorted back-to-front based on depth
3. Triangles are drawn in order to ensure proper occlusion

### Input Handling
The program supports several user interaction methods:
- **Keyboard** - Left/right arrows for rotation, up/down arrows for zooming
- **Mouse Drag** - Click and drag to rotate the view
- **Mouse Wheel** - Scroll to zoom in/out

## Code Structure

### Key Variables
- **Screen and Terrain Configuration**: Controls the dimensions and level of detail
- **Camera Parameters**: Defines the fixed camera position and zoom limits
- **World Rotation**: Controls the rotation of the world around the Y-axis
- **Input State**: Tracks the current state of user inputs

### Main Functions
- **generateTerrain()**: Creates the heightmap using Perlin noise and mathematical formulas
- **project()**: Projects 3D points onto the 2D screen using world rotation and perspective projection
- **getTerrainColor()**: Determines terrain color based on height
- **Love2D Callbacks**: Handle rendering, updates, and input processing

## Bug Fixes
1. **Fixed Rotation Issue**: Replaced camera rotation with world rotation to create proper orbiting
   ```lua
   -- Instead of moving the camera, we now rotate the world:
   local worldX = point.x * math.cos(worldRotationY) - point.z * math.sin(worldRotationY)
   local worldZ = point.x * math.sin(worldRotationY) + point.z * math.cos(worldRotationY)
   ```

2. **Added Zoom Functionality**: Implemented camera zooming with keyboard and mouse wheel
   ```lua
   -- Zoom with keyboard
   if isZoomingIn then
       cameraZ = cameraZ + zoomSpeed
       if cameraZ > -minZoomDistance then cameraZ = -minZoomDistance end
   end
   
   -- Zoom with mouse wheel
   function love.wheelmoved(x, y)
       if y > 0 then  -- Scroll up to zoom in
           cameraZ = cameraZ + zoomSpeed * 3
           -- limit checking...
       end
   end
   ```

## Usage Instructions
- **Launch**: Run using the Love2D framework
- **Orbit**: 
  - Press left/right arrow keys to rotate the world
  - Alternatively, click and drag with the mouse horizontally
- **Zoom**:
  - Press up/down arrow keys to zoom in/out
  - Use mouse scroll wheel to zoom in/out
- **Exit**: Press ESC to quit the application

## Future Improvements
- Add height-based texture mapping
- Implement fog/distance effects
- Add more camera controls (zoom, elevation)
- Add day/night cycle with lighting effects
- Optimize rendering for larger terrain sizes
- Add water features (lakes, rivers)
- Add elevation controls to view from different heights
- Add minimap or position indicator
